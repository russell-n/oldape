Kill All
========

A module to kill processes.

.. currentmodule:: apetools.tools.killall

<<name='imports', echo=False>>=
#python
import re

# apetools
from apetools.baseclass import BaseClass
from apetools.tools import sleep
from apetools.commons import enumerations, expressions, errors
from apetools.parsers.oatbran import NAMED, STRING_START,SPACES, INTEGER
from apetools.commands.pscommand import PsGrep
from apetools.commands.topcommand import TopGrep
@

<<name='constants', echo=False>>=
CYGWIN = STRING_START + SPACES + NAMED(n=expressions.PID_NAME,e=INTEGER)

operating_systems = enumerations.OperatingSystem

@

KillAllError
------------

The `KillAllError` is raised if an error specific to the command is detected.

.. uml::

   KillAllError -|> CommandError

<<name='KillAllError', echo=False>>=
class KillAllError(errors.CommandError):
    """
    A KillAllError is raised if the kill didn't succeed.
    """
@

KillAll
-------

The `KillAll` command (it probably should not be in the `tools`) kills processes.

.. autosummary::
   :toctree: api

   KillAll

.. uml::

   KillAll -|> BaseClass
   KillAll : name
   KillAll : time_to_sleep
   KillAll : expression
   KillAll : run(connection, name, time_to_sleep)
   KillAll : __call__(connection, name, time_to_sleep)

* The `name` parameter is the name of a process to kill.

* The `time_to_sleep` parameter is an amount of time to wait before checking that the process was successfully killed.

* The `connection` is a connection to the device.

* all the constructor parameters can be passed in to the call instead

* The expected ``ps`` output currently matches the standard GNU output (a la *Ubuntu*), android, and Cygwin

<<name='KillAll', echo=False>>=
class KillAll(BaseClass):
    """
    A killall kills processes. The default operating system is linux
    """
    def __init__(self, name=None, time_to_sleep=None, connection=None):
        """
        :param:

         - `name`: The name of a process to kill
         - `time_to_sleep`: The number of seconds to wait for a process to die.
         - `connection`: A connection to a device
        """
        super(BaseClass, self).__init__()
        self._logger = None
        self.name = name
        self._expression = None
        self._arguments = None
        self.time_to_sleep = time_to_sleep
        self._sleep = None
        self.connection = None
        return


    @property
    def sleep(self):
        """
        A sleep object to pace the execution of commands on the device
        
        :return: A sleep timer
        """
        if self._sleep is None:
            self._sleep = sleep.Sleep(self.time_to_sleep).run
        return self._sleep
    
    def run(self, connection=None, name=None, time_to_sleep=None):
        """
        Executes the kill
        
        :param:

         - `connection`: the connection to the device
         - `name`: The process to kill
         - `time_to_sleep`: Seconds between calls to the device

        :raise: KillAllError if the process is still alive at the end
        :postcondition: self.connection set to connection
        """
        if connection is not None:
            self.connection = connection

        if name is None:
            name = self.name
        
        if time_to_sleep is None:
            time_to_sleep = self.time_to_sleep

        if self.connection.operating_system == operating_system.ios:
            grep = TopGrep(self.connection)
        else:
            grep = PsGrep(self.connection)

        self.logger.debug("process to kill: {0}".format(name))

        for pid in grep():
            self.logger.debug("killing: " + match.group(ProcessGrepEnum.pid))
            command = " -9 " + match.group(ProcessGrepEnum.Process)
            kill_count+= 1
            self.logger.debug("kill " + command)
            k_output, k_error = self.connection.kill(command)
            for k_line in k_error:
                if len(k_line) > 1:
                    self.logger.error(k_line)

        if not kill_count:
            self.logger.info("No iperf sessions found on {0}".format(self.connection.hostname))
            return

        self.sleep(time_to_sleep)

        # double-check to see if the process is dead
        for pid in grep():
            raise KillAllError("Unable to kill {0}".format(name))
            self.logger.error(err)
        self.logger.info("Killed {0} iperf processes on {1}".format(kill_count, self.connection.hostname))
        return

    def __call__(self, connection, name=None, time_to_sleep=None):
        """
        This is an alias to ``run`` to match the newer-style
        
        :param:

         - `connection`: connection to the device
        """
        self.run(connection=connection, name=name, time_to_sleep=time_to_sleep)
        return
    
    def __str__(self):
        return "{0} ({2}):{1}".format(self.__class__.__name__, self.name, self.connection)
# end class KillAll
@
